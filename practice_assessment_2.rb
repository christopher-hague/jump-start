# -------------------------------------------------------------------
# Instructions
# -------------------------------------------------------------------
# This file is in the same format as your assessments.
#
# Make sure everything puts out as 'true' when you run the file.
#
# Give yourself an hour to complete this assessment.
# When time is up, make sure you don't have any unexpected `end`s or
# infinite loops that would keep your code from running.
#
# Rename the file to be your firstname and lastname.
#
# Do not use the internet.  If you forget a particular ruby method,
# write it yourself.
#
# Test your code with a few cases in addition to the ones we give
# you.  When we grade you, we use different test cases to make sure your
# logic is sound.
#
# Look at the test cases below the problem before you approach it.
# Use the debugger when code doesn't run how you expect.
# -------------------------------------------------------------------

# Greatest Common Factor
# --------------------------------------------------------------------
# Return the greatest number which is a factor of both inputs.
#
# The greatest common factor of 6 and 10 is 2
# the greatest common factor of 10 and 15 is 5

def greatest_common_factor(first_number, second_number)
  i = [first_number, second_number].min

  while i > 1
    return i if first_number % i == 0 && second_number % i == 0
    i -= 1
  end

  i
end

puts "-------Greatest Common Factor-------"

puts greatest_common_factor(6, 10) == 2
puts greatest_common_factor(10, 15) == 5
puts greatest_common_factor(4, 7) == 1
puts greatest_common_factor(4, 8) == 4

# Panoramic Pairs
# -------------------------------------------------------------------
# You have a panoramic view in front of you, but you only can take a
# picture of two landmarks at a time (your camera is small).
# You want to capture every pair of landmarks that are next to each
# other.
#
# Given an array of landmarks, return every adjacent pair from left to
# right. Assume the panorama wraps around.

def panoramic_pairs(landmarks)
  result = []

  (0...landmarks.length).each do |i|
    if i == landmarks.length - 1
      result << [landmarks[-1], landmarks[0]]
    else
      result << [landmarks[i], landmarks[i + 1]]
    end
  end

  result
end

puts "-------Panoramic Pairs-------"

landmarks_1 = ["House", "Horse"]
pairs_1 = [["House", "Horse"], ["Horse", "House"]]

puts panoramic_pairs(landmarks_1) == pairs_1

landmarks_2 = ["Tree", "Mountain", "Ocean", "Cottage"]
pairs_2 = [["Tree", "Mountain"], ["Mountain", "Ocean"], ["Ocean", "Cottage"], ["Cottage", "Tree"]]

puts panoramic_pairs(landmarks_2) == pairs_2


# Two Degrees of Separation
# --------------------------------------------------------------------
# You have a hash that represents all of Facebook (lookit you).  Each
# key is the name of a person on facebook, and each value is an array
# of all their friends. Assume everyone on Facebook has a different name.
#
# Given Facebook and the name of a person, return an array of all the
# friends of their friends. Do not include the original person or their
# immediate friends.

def two_degrees_away(facebook, name)
  result = []

  facebook[name].each do |friend|
    facebook[friend].each do |friend_of|
      result << friend_of unless friend_of == name || facebook[name].include?(friend_of)
    end
  end

  result
end


puts "-------Two Degrees of Separation-------"

facebook_1 = {
  "Harry Potter" => ["Ron Weasley"],
  "Ron Weasley" => ["Harry Potter", "Fred Weasley"],
  "Fred Weasley" => ["Ron Weasley"]
}

friends_1 = ["Fred Weasley"]

puts two_degrees_away(facebook_1, "Harry Potter") == friends_1


facebook_2 = {
  "Mark Zuckerberg" => ["Eduardo Saverin", "Dustin Moskovitz", "Sean Parker"],
  "Eduardo Saverin" => ["Mark Zuckerberg", "Tyler Winklevoss", "Cameron Winklevoss", "Dustin Moskovitz"],
  "Tyler Winklevoss" => ["Eduardo Saverin"],
  "Cameron Winklevoss" => ["Eduardo Saverin"],
  "Dustin Moskovitz" => ["Mark Zuckerberg", "Eduardo Saverin"],
  "Sean Parker" => ["Mark Zuckerberg"]
}

friends_2 = ["Tyler Winklevoss", "Cameron Winklevoss"]

puts two_degrees_away(facebook_2, "Mark Zuckerberg") == friends_2


# Assign Pods
# --------------------------------------------------------------------
# You are a JumpStart TA and you need to assign students to sit with
# other students who are at the same place in the curriculum.
#
# Given a list of students ordered by how far they are in the course
# and a list of pods, return their seat assignments.  Assume you can
# only seat four people per pod.  "Fill up" each pod as you go.  It's
# OK to have a pod with four people and the next pod with one person).
# It's OK to have empty pods if there aren't enough students.

def assign_pods(students, pods)
  result = {}
  pods.each { |pod| result[pod] = [] }
  i = 0

  students.each do |name|
    result[pods[i]] << name
    i += 1 if result[pods[i]].length == 4
  end

  result
end

puts "-------Assign Pods-------"

students_1 = [
  "Scott",
  "Asher",
  "Julie",
  "Rick",
  "Jeff",
  "Brooke",
  "Sandra",
  "Jim",
  "Pete",
  "Marta",
  "Tanna"
]

pods_1 = [
  "Fremont",
  "Berkeley",
  "San Ramon"
]


expected_pod_assignment_1 = {
  "Fremont" => ["Scott", "Asher", "Julie", "Rick"],
  "Berkeley" => ["Jeff", "Brooke", "Sandra", "Jim"],
  "San Ramon" => ["Pete", "Marta", "Tanna"]
}

students_2 = [
  "Scott",
  "Asher",
  "Julie",
  "Rick",
  "Jeff",
  "Brooke",
  "Sandra",
  "Jim",
  "Pete",
  "Marta",
  "Tanna",
  "Fred",
  "George"
]

pods_2 = [
  "Fremont",
  "Berkeley",
  "San Ramon",
  "Oakland"
]


expected_pod_assignment_2 = {
  "Fremont" => ["Scott", "Asher", "Julie", "Rick"],
  "Berkeley" => ["Jeff", "Brooke", "Sandra", "Jim"],
  "San Ramon" => ["Pete", "Marta", "Tanna", "Fred"],
  "Oakland" => ["George"]
}

puts assign_pods(students_1, pods_1) == expected_pod_assignment_1
puts assign_pods(students_2, pods_2) == expected_pod_assignment_2


# Remove Letter 'A'
# ---------------------------------------------------------------------
# Given a list of words, remove all the occurrences of the letter 'a'
# in those words.

def remove_letter_a(words)
  words.map { |word| remove_a(word) }
end

def remove_a(word)
  result = ""
  word.each_char { |char| result += char unless char == "a" }
  result
end


puts "-------Remove Letter 'A'-------"

words_1 = ["blueberry", "apple", "banana", "peach"]
without_a_1 = ["blueberry", "pple", "bnn", "pech"]

words_2 = ["syllabus", "smirk", "salamander", "saaaaaaa"]
without_a_2 = ["syllbus", "smirk", "slmnder", "s"]

puts remove_letter_a(words_1) == without_a_1
puts remove_letter_a(words_2) == without_a_2


# Care Bear Summary
# --------------------------------------------------------------------
# You have a calendar of hugs that care bears made (given as a list of
# names by care bears).  Some of them have hugged multiple
# times in a row.
#
# Return a hash where the keys are the care bears and the values are an
# array of all of the start and end days of their hugging streaks.
#
# Days are the index of the calendar array.

def care_bear_summary(calendar_of_hugs)
  result = Hash.new { |k, v| k[v] = [] }
  indices = []

  (0...calendar_of_hugs.length).each do |i|
    if calendar_of_hugs[i] == calendar_of_hugs[i + 1]
      indices << i if indices.empty?
    elsif calendar_of_hugs[i] != calendar_of_hugs[i + 1]
      unless indices.empty?
        indices << i
        result[calendar_of_hugs[i]] << indices
        indices = Array.new
      end
    end
  end

  result
end

puts "-------Care Bear Summary-------"

hug_calendar_1 = [
  "Birthday Bear",
  "Bedtime Bear",
  "Birthday Bear",
  "Birthday Bear",
  "Bedtime Bear"
]

care_bear_counts_1 = {
  "Birthday Bear" => [[2, 3]]
}

hug_calendar_2 = [
  "Birthday Bear",
  "Birthday Bear",
  "Cheer Bear",
  "Bedtime Bear",
  "Bedtime Bear",
  "Birthday Bear",
  "Birthday Bear",
  "Birthday Bear",
  "Bedtime Bear",
  "Friend Bear"
]

care_bear_counts_2 = {
  "Birthday Bear" => [[0, 1], [5, 7]],
  "Bedtime Bear" => [[3, 4]]
}

puts care_bear_summary(hug_calendar_1) == care_bear_counts_1
puts care_bear_summary(hug_calendar_2) == care_bear_counts_2
